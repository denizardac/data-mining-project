# -*- coding: utf-8 -*-
"""son.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14lmTVaGCqA7GwniPaKd8zdOwg1A7Lzwb
"""

import pandas as pd
from google.colab import files
from sklearn.impute import KNNImputer
from sklearn.model_selection import StratifiedKFold
from sklearn.metrics import (
    accuracy_score, f1_score, precision_score, recall_score, matthews_corrcoef, roc_auc_score
)
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier, ExtraTreesClassifier
from sklearn.svm import SVC
from sklearn.linear_model import LogisticRegression, Perceptron
from sklearn.neighbors import KNeighborsClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import AdaBoostClassifier
import numpy as np


# 1. Dosyayı yükleme işlemi
print("Lütfen Excel dosyanızı yükleyin...")
uploaded = files.upload()

# 2. Yüklenen dosyanın adını belirleme
Data_processed_xlsx = list(uploaded.keys())[0]
print(f"Yüklenen dosya adı: {Data_processed_xlsx}")

# 3. Excel dosyasını pandas ile okuma
df = pd.read_excel(Data_processed_xlsx)

# 4. Grain Yield sütununu sayısal değerlere dönüştürme
print(df['GrainYield'].unique())
df['GrainYield'] = df['GrainYield'].str.replace(r'\xa0', '', regex=True)
df['GrainYield'] = df['GrainYield'].replace({'C': 0, 'B': 1, 'A': 2})

# 5. Eksik veri analizi
print("\nEksik veri durumu:")
print(df.isnull().sum()[df.isnull().sum() > 0])

# 6. Sayısal ve kategorik sütunları ayırma
numeric_cols = df.select_dtypes(include=['number']).columns
categorical_cols = df.select_dtypes(include=['object']).columns

# 7. SAYISAL SÜTUNLAR İÇİN: Ortalama (mean) ile doldurma
for col in numeric_cols:
    if df[col].isnull().sum() > 0:
        df[col].fillna(df[col].mean(), inplace=True)

# 8. KATEGORİK SÜTUNLAR İÇİN: Mod (en sık değer) ile doldurma
for col in categorical_cols:
    if df[col].isnull().sum() > 0:
        df[col].fillna(df[col].mode()[0], inplace=True)

# 9. KNN İLE KOMPLEKS EKSİK VERİ DOLDURMA (Tüm sayısal sütunlar)
# Eğer eksik sayısal veriler kalırsa KNN kullanarak doldur
if df[numeric_cols].isnull().sum().sum() > 0:
    knn_imputer = KNNImputer(n_neighbors=5)
    df[numeric_cols] = knn_imputer.fit_transform(df[numeric_cols])

# 10. Eksik verilerin son durumu
print("\nDoldurulmuş eksik verilerin sayısı:")
print(df.isnull().sum())

# 11. İşlenmiş veriyi yeni bir Excel dosyasına kaydedin
output_file = "Data_processed.xlsx"
# Instead of df_filled, use df as it contains the filled data
df.to_excel(output_file, index=False) # Changed df_filled to df

# 12. Dosyayı indirin
files.download(output_file)

# Hedef sütunu karaktere çevirerek özel değerleri kontrol edin
df['Longitude'] = df['Longitude'].astype(str)  # Replace 'data' with 'df'

# Sorunlu değerleri belirli bir formata çevirmek
df['Longitude'] = df['Longitude'].str.replace(r'85\.1\s*4', '85.14', regex=True)  # Replace 'data' with 'df'

# Sayısala dönüştürme
df['Longitude'] = pd.to_numeric(df['Longitude'], errors='coerce')  # Replace 'data' with 'df'

# Sonuçları kontrol et
print(df['Longitude'].unique())  # Benzersiz değerleri kontrol edin # Replace 'data' with 'df'

from sklearn.feature_selection import SelectFromModel
from sklearn.metrics import accuracy_score
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier, ExtraTreesClassifier, AdaBoostClassifier
from sklearn.svm import SVC
from sklearn.linear_model import LogisticRegression, Perceptron
from sklearn.neighbors import KNeighborsClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.tree import DecisionTreeClassifier
from sklearn.preprocessing import LabelEncoder
import pandas as pd
from sklearn.model_selection import train_test_split

# 3. 'Grain Yield' kategorisini dönüştürme
df['GrainYield'] = df['GrainYield'].replace({'C': '1', 'B': '2', 'A': '3'})

# 4. PreviousCrop sütunlarını seçme (Longitude'dan DaysFromHerbicideToHarvest'a kadar olan sütunlar)
feature_cols = ['Longitude', 'Latitude', 'PrevCropResidue', 'SeedRate', 'BasalDAP', 'BasalNPK', 'BasalMOP', 'BasalZn',
                'Split1Urea', 'Split2Urea', 'Split3Urea', 'IrrigationNumber', 'FirstIrrigationDay', 'SecondIrrigationDay',
                'ThirdIrrigationDay', 'HerbicideDose', 'WeedingNumber', 'YearYear', 'YearMonth', 'YearDay', 'YearWeekNum',
                'SowingYear', 'SowingMonth', 'SowingDay', 'SowingWeekNum', 'HerbicideYear', 'HerbicideMonth', 'HerbicideDay',
                'HerbicideWeekNum', 'HarvestYear', 'HarvestMonth', 'HarvestDay', 'HarvestWeekNum', 'DaysFromZerotoSowing',
                'DaysFromSowingToHerbicide', 'DaysFromHerbicideToHarvest']

# 5. Hedef değişkeni ('Grain Yield') ve özellikleri (features) ayırma
X = df[feature_cols]
y = df['GrainYield']

# 6. Kategorik hedef değişkeni sayısal hale getirme
le = LabelEncoder()
y = le.fit_transform(y)

# 7. Eğitim ve test verilerini ayırma
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# 8. Modelleri tanımlama
models = {
    'Random Forest': RandomForestClassifier(),
    'Gradient Boosting': GradientBoostingClassifier(),
    'Extra Trees': ExtraTreesClassifier(),
    'SVM': SVC(),
    'Logistic Regression': LogisticRegression(),
    'K-Nearest Neighbors': KNeighborsClassifier(),
    'Naive Bayes': GaussianNB(),
    'Decision Tree': DecisionTreeClassifier(),
    'Perceptron': Perceptron(),
    'AdaBoost': AdaBoostClassifier()
}

# 9. PreviousCrop sütunlarına göre eğitim ve doğruluk hesaplama
previous_crop_cols = ['PreviousCrop_Fallow', 'PreviousCrop_Maize', 'PreviousCrop_Rice', 'PreviousCrop_Soybean']

# 10. CropEstablishment sütunlarını seçme
crop_establishment_cols = ['CropEstablishment_CT', 'CropEstablishment_CT_line', 'CropEstablishment_ZT']

# 11. Sonuçları saklamak için bir sözlük oluşturma
accuracy_results = {'PreviousCrop': {}, 'CropEstablishment': {}}

# 12. Feature Selection for each PreviousCrop type
for col in previous_crop_cols:
    # Sadece "1" olan değerleri alarak model eğitimi yapma
    X_col = X[df[col] == 1]
    y_col = y[df[col] == 1]

    if len(X_col) > 0:  # Eğer "1" olan satır varsa
        # Sayısal hale getirme işlemi ve NaN'leri doldurma
        X_col = X_col.apply(pd.to_numeric, errors='coerce')
        X_col.fillna(X_col.mean(), inplace=True)

        # Eğitim ve test verisini bölme
        X_train_col, X_test_col, y_train_col, y_test_col = train_test_split(X_col, y_col, test_size=0.2, random_state=42)

        # Feature Selection: Use RandomForest to select the best features
        rf = RandomForestClassifier()
        rf.fit(X_train_col, y_train_col)
        selector = SelectFromModel(rf, threshold="mean", max_features=10)  # Select top 10 features based on importance
        X_train_selected = selector.transform(X_train_col)
        X_test_selected = selector.transform(X_test_col)

        # Modelleri eğitme ve doğruluğu hesaplama (all features)
        for model_name, model in models.items():
            model.fit(X_train_col, y_train_col)
            y_pred_col = model.predict(X_test_col)
            accuracy_all_features = accuracy_score(y_test_col, y_pred_col)

            # Modelleri eğitme ve doğruluğu hesaplama (selected features)
            model.fit(X_train_selected, y_train_col)
            y_pred_selected = model.predict(X_test_selected)
            accuracy_selected_features = accuracy_score(y_test_col, y_pred_selected)

            # Sonuçları saklama
            if col not in accuracy_results['PreviousCrop']:
                accuracy_results['PreviousCrop'][col] = {}
            accuracy_results['PreviousCrop'][col][f"{model_name} - All Features"] = accuracy_all_features
            accuracy_results['PreviousCrop'][col][f"{model_name} - Selected Features"] = accuracy_selected_features

# 13. Feature Selection for each CropEstablishment type
for col in crop_establishment_cols:
    # Sadece "1" olan değerleri alarak model eğitimi yapma
    X_col = X[df[col] == 1]
    y_col = y[df[col] == 1]

    if len(X_col) > 0:  # Eğer "1" olan satır varsa
        # Sayısal hale getirme işlemi ve NaN'leri doldurma
        X_col = X_col.apply(pd.to_numeric, errors='coerce')
        X_col.fillna(X_col.mean(), inplace=True)

        # Eğitim ve test verisini bölme
        X_train_col, X_test_col, y_train_col, y_test_col = train_test_split(X_col, y_col, test_size=0.2, random_state=42)

        # Feature Selection: Use RandomForest to select the best features
        rf = RandomForestClassifier()
        rf.fit(X_train_col, y_train_col)
        selector = SelectFromModel(rf, threshold="mean", max_features=10)  # Select top 10 features based on importance
        X_train_selected = selector.transform(X_train_col)
        X_test_selected = selector.transform(X_test_col)

        # Modelleri eğitme ve doğruluğu hesaplama (all features)
        for model_name, model in models.items():
            model.fit(X_train_col, y_train_col)
            y_pred_col = model.predict(X_test_col)
            accuracy_all_features = accuracy_score(y_test_col, y_pred_col)

            # Modelleri eğitme ve doğruluğu hesaplama (selected features)
            model.fit(X_train_selected, y_train_col)
            y_pred_selected = model.predict(X_test_selected)
            accuracy_selected_features = accuracy_score(y_test_col, y_pred_selected)

            # Sonuçları saklama
            if col not in accuracy_results['CropEstablishment']:
                accuracy_results['CropEstablishment'][col] = {}
            accuracy_results['CropEstablishment'][col][f"{model_name} - All Features"] = accuracy_all_features
            accuracy_results['CropEstablishment'][col][f"{model_name} - Selected Features"] = accuracy_selected_features

# 14. Sonuçları yazdırma
print("\nPreviousCrop sütunlarına göre her bir modelin doğruluk oranları (All vs Selected Features):")
for col, results in accuracy_results['PreviousCrop'].items():
    print(f"\n{col}:")
    for model_name, accuracy in results.items():
        print(f"{model_name}: {accuracy:.4f}")

print("\nCropEstablishment sütunlarına göre her bir modelin doğruluk oranları (All vs Selected Features):")
for col, results in accuracy_results['CropEstablishment'].items():
    print(f"\n{col}:")
    for model_name, accuracy in results.items():
        print(f"{model_name}: {accuracy:.4f}")

from sklearn.metrics import roc_auc_score, precision_score, recall_score, f1_score, matthews_corrcoef

# Yeni sonuçları saklamak için bir sözlük
metric_results = {'PreviousCrop': {}, 'CropEstablishment': {}}

# Fonksiyon: Tüm metrikleri hesaplama
def calculate_metrics(y_true, y_pred, model_name, col, category, model):
    precision = precision_score(y_true, y_pred, average='weighted', zero_division=0)
    recall = recall_score(y_true, y_pred, average='weighted', zero_division=0)
    f1 = f1_score(y_true, y_pred, average='weighted')
    mcc = matthews_corrcoef(y_true, y_pred)

    # AUC hesaplama (her modelin predict_proba fonksiyonu farklı olabilir)
    try:
        auc = roc_auc_score(y_true, model.predict_proba(X_test_selected), multi_class='ovr', average='weighted')
    except AttributeError:
        auc = "N/A"  # Eğer predict_proba mevcut değilse

    # Sonuçları saklama
    if col not in metric_results[category]:
        metric_results[category][col] = {}
    metric_results[category][col][model_name] = {
        'Precision': precision,
        'Recall': recall,
        'F1 Score': f1,
        'MCC': mcc,
        'AUC': auc
    }

# PreviousCrop metriklerini hesaplama
for col, results in accuracy_results['PreviousCrop'].items():
    for model_name, accuracy in results.items():
        if "Selected Features" in model_name:  # Sadece seçilen özelliklerle yapılan sonuçlar
            model = models[model_name.split(" - ")[0]]  # Modeli seç
            y_pred = model.predict(X_test_selected)  # Modelin tahminlerini al
            calculate_metrics(y_test_col, y_pred, model_name, col, 'PreviousCrop', model)

# CropEstablishment metriklerini hesaplama
for col, results in accuracy_results['CropEstablishment'].items():
    for model_name, accuracy in results.items():
        if "Selected Features" in model_name:  # Sadece seçilen özelliklerle yapılan sonuçlar
            model = models[model_name.split(" - ")[0]]  # Modeli seç
            y_pred = model.predict(X_test_selected)  # Modelin tahminlerini al
            calculate_metrics(y_test_col, y_pred, model_name, col, 'CropEstablishment', model)

# Metrik sonuçlarını yazdırma
print("\nPreviousCrop sütunlarına göre her bir modelin metrikleri (Selected Features):")
for col, results in metric_results['PreviousCrop'].items():
    print(f"\n{col}:")
    for model_name, metrics in results.items():
        print(f"{model_name}:")
        for metric_name, value in metrics.items():
            print(f"  {metric_name}: {value:.4f}" if isinstance(value, (float, int)) else f"  {metric_name}: {value}")

print("\nCropEstablishment sütunlarına göre her bir modelin metrikleri (Selected Features):")
for col, results in metric_results['CropEstablishment'].items():
    print(f"\n{col}:")
    for model_name, metrics in results.items():
        print(f"{model_name}:")
        for metric_name, value in metrics.items():
            print(f"  {metric_name}: {value:.4f}" if isinstance(value, (float, int)) else f"  {metric_name}: {value}")

import matplotlib.pyplot as plt
from sklearn.metrics import roc_curve, auc

# ROC Eğrisini çizme ve tekrarsız çizim fonksiyonu
def plot_combined_roc_curve_unique(X_test_selected, y_test_col, models, metric_results):
    # Grafik ayarları
    plt.figure(figsize=(12, 8))

    color_index = 0
    color_list = ['b', 'g', 'r', 'c', 'm', 'y', 'k', 'orange', 'pink', 'brown']
    used_names = set()  # Çizilmiş model isimlerini saklama

    # Tüm kategoriler için ROC eğrilerini çizme
    for category in metric_results.keys():
        for col, results in metric_results[category].items():
            for model_name, metrics in results.items():
                if metrics['AUC'] != "N/A" and model_name not in used_names:  # Daha önce çizilmemişse
                    model = models[model_name.split(" - ")[0]]  # Modeli seç
                    # ROC eğrisini hesapla
                    fpr, tpr, _ = roc_curve(y_test_col, model.predict_proba(X_test_selected)[:, 1], pos_label=1)
                    roc_auc = auc(fpr, tpr)

                    # ROC eğrisini çiz
                    color = color_list[color_index % len(color_list)]  # Renk seçimi
                    plt.plot(fpr, tpr, color=color, label=f'{category} - {model_name} (AUC = {roc_auc:.4f})')
                    used_names.add(model_name)  # Kullanılmış olarak işaretle
                    color_index += 1

    # Grafik ayarları
    plt.plot([0, 1], [0, 1], color='navy', linestyle='--', label='Random Guess')
    plt.xlim([0.0, 1.0])
    plt.ylim([0.0, 1.05])
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('Combined ROC Curve for Unique Models')
    plt.legend(loc="lower right")  # Etiketleri grafikte göster
    plt.grid(True)

    # Grafiği göster
    plt.show()

# Tek ROC eğrisi çizme
plot_combined_roc_curve_unique(X_test_selected, y_test_col, models, metric_results)

import seaborn as sns
from sklearn.metrics import confusion_matrix
import matplotlib.pyplot as plt

# En iyi modeli seçmek için metrikleri karşılaştırma (Örnek olarak AUC'yi kullanıyoruz)
best_model_name = None
best_auc = 0

# En iyi modeli bulma (AUC değerine göre)
for category in metric_results.keys():
    for col, results in metric_results[category].items():
        for model_name, metrics in results.items():
            auc = metrics['AUC']
            if auc != "N/A" and auc > best_auc:
                best_auc = auc
                best_model_name = model_name

# En iyi modeli yazdırma
print(f"En iyi model: {best_model_name}")
print(f"En iyi model AUC değeri: {best_auc:.4f}")

# En iyi modelin tahminini almak
best_model = models[best_model_name.split(" - ")[0]]
y_pred_best_model = best_model.predict(X_test_selected)

# Confusion Matrix hesaplama
cm = confusion_matrix(y_test_col, y_pred_best_model)

# Confusion Matrix'i görselleştirme
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=True, yticklabels=True)
plt.title(f'Confusion Matrix for Best Model: {best_model_name}')
plt.xlabel('Predicted Labels')
plt.ylabel('True Labels')
plt.show()